

<p>At procedural languages key building blocks are data types, and all their operations are defined and built into syntax. Functional paradigm evaluates code to mathematical functions, avoiding mutable data. Among procedural languages are C, C#, Rust. The most known functional languages are Haskell, Closure, Erland. Note that many languages are claimed to belong to different paradigms or have features of many, and, being so, called multi-paradigm, including imperative model too, like C family and mostly C++. 
  Each one familiar with Ruby at least a bit is told that everything in Ruby is an object,- it's of Smalltalk language influence, that applied to all of Ruby: each data unit is an object, with own methods and instance variables assigned to.  Since that you are prepared, from very first book ( like Chris Pine's "Learn to Program"), to learn object defined and inheritance paradigm and look at everything from this point of view. Every data piece in Ruby is it's class instance, having useful class methods and inheriting them from parent class. There is a fundamental approach claiming to learn inheritance and classes first and syntax second ("THE RUBY WAY", Hal Fulton) - that is how important OOP knowledge is to Ruby programmer. More popular studying method for Ruby OOP introducts it after syntax and basic consepts and divides into two parts: first is teaching classes, class methods and variables, basic inheritance principles, instance variables and second introduces to more advanced stuff: modules, mixins, constants, private and protected methods. 
What problems does object-oriented paradigm solve? Because of growing complexity of applications, and the fact that at real life they could be claimed for changes, one mistake could ruin large piece of work, repeat and grow causing bigger errors. According to this design model code is ordered the way it changes once and simply at appropriate order and hierarchy, doesn't repeat and confuse. As we stated, it's good for effective software production. Nevertheless, object-oriented programming principles serve modern developer's growing and consistensy,- explore what  exactly fundamental OOP principles look like at Ruby and what they do for you.
Polymorphism is an ability af data to be represent at different types. At our language ( we don't cover other languages' principles here), polymorphism comes as different behaviour of same methods on different classes objects ( and inheritant classes). Ruby module - an example of polymorphic building in Ruby,- is an independent structure, defined on top of class hierarchy, which has not own instances, but is included using the same name method 'include' by classes to build in its behaviour no matter of hierarchy. The way module is included into classes is called mixin. And, unlike classes hierarchy, you can inherit from many modules that way. 
Duck typing in Ruby defines behaviour of an object rather by what it does, than by it's name. At older obect-oriented languages classes are types and support interfaces. At Ruby classes aren't types. Moreover, Ruby class is more defined and described by what it does (class methods) rather than what it and it's variables called. It can appear at real testing or development tasks, showing that Ruby is agile language first, and it's classes aren't types and object's aren't typed as at some other languages. Thus, duck typing in Ruby is opposed to other languages ( like Java) static typing.  How do these principles help in practice? Object-oriented design model is making you write short methods performing one particular action for each with limited scope of variables and then test them, which is safe and effective excluding errors. 
Incaplulation is ability to define a scope for data to hide it and it's functionality from external access. Ruby has variable scopes at each level, but in its class structure there are other important features to limit access to some methods: keywords "private" and "protected". In practice it's not only bug fighting, but also security matter, so that other class methods and outsiders don't have access to sensitive data of your application! Modules' way to depict object's methods and behavior serve incapulation idea too, because due to them, accomplished code units are stored independently.
The main basic principle for Ruby OOP is inheritance: Ruby child class (subclass) inherits its behaviour from parent class and from superclass. It becomes handy to define basic features at parental class and then customize child classes, specifying details. Look at ruby-doc.org at Core section; maybe, your first glance at Ruby docs was on String class methods. You will see that String inherits from Object, which superclass is BasicObject, the parent class for all. Prepare to know about such Ruby classes as TrueClass, Regexp, TCPServer, and Time..This way, from beginning you get used to class hierarchy and order as class methods are used and called on class instances, at one hand, and flexibility as you can use them and build your own classes, the other hand. You are free to write your own methods to existent Ruby classes but there's a fundamental saying that it's better to avoid it, especially on beginning, because you are on a long way to master using and combining all present methods first.
Modern programmers developed object-oriented design model, refining fundamental concept due to better code functionality and safety. One of this model's principles from SOLID, by M.Feathers and R.Martin, describing modern agile development basis of object-oriented programming and refactoring, where "S" stands for "single responsibility", is creating classes of single responsibility for better organization and availability for changes. According to this principle, class, same as its methods, should be simple, transparent, and perform one purpose/ action. 
  Go on studying object-oriented programming in Ruby, further exploration and solid knowledge of it will refund you well. 
  As authors of famous "Pickaxe" said, "spend your time creating solutions for your users, not for the compiler". </p>
